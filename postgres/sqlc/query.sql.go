// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getCity = `-- name: GetCity :one
SELECT id, name, created_at, deleted_at FROM city WHERE name = $1
`

func (q *Queries) GetCity(ctx context.Context, name string) (City, error) {
	row := q.db.QueryRowContext(ctx, getCity, name)
	var i City
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getHourses = `-- name: GetHourses :many
WITH duplicate_conditions AS (
    SELECT MIN(id) AS id, section_id, address, age, area
    FROM hourse
    WHERE link LIKE 'https://sale.591.com.tw/home%'
    AND updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
    GROUP BY section_id, address, age, area
    HAVING count(1) > 1
),
duplicate AS (
    SELECT hourse.id
    FROM hourse
    INNER JOIN duplicate_conditions ON(
            hourse.section_id = duplicate_conditions.section_id
        AND hourse.address = duplicate_conditions.address
        AND hourse.age = duplicate_conditions.age
        AND hourse.area = duplicate_conditions.area
        AND hourse.link LIKE 'https://sale.591.com.tw/home%'
    )
    WHERE hourse.id NOT IN (SELECT id FROM duplicate_conditions)
    AND hourse.updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
),
candidates AS (
SELECT hourse.id
FROM hourse
INNER JOIN section ON(hourse.section_id = section.id)
INNER JOIN city ON(section.city_id = city.id)
INNER JOIN shape ON(hourse.shape_id = shape.id)
WHERE hourse.updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
    AND hourse.id NOT IN (SELECT id FROM duplicate)
    AND (COALESCE($1, '') = '' OR city.name = ANY(string_to_array($1, ',')))
    AND (COALESCE($2, '') = '' OR section.name = ANY(string_to_array($2, ',')))
    AND (COALESCE($3, '') = '' OR shape.name LIKE ANY(string_to_array($3, ',')))
    AND (COALESCE($4, '') = '' OR hourse.price <= $4 :: DECIMAL)
    AND (COALESCE($5, '') = '' OR hourse.price > $5 :: DECIMAL)
    AND (COALESCE($6, '') = '' OR hourse.age < $6)
    AND (COALESCE($7, '') = '' OR hourse.main_area <= $7 :: DECIMAL)
    AND (COALESCE($8, '') = '' OR hourse.main_area > $8 :: DECIMAL)
)
SELECT
    hourse.id, hourse.universal_id, hourse.section_id, hourse.shape_id, hourse.link, hourse.layout, hourse.address, hourse.price, hourse.floor, hourse.age, hourse.area, hourse.main_area, hourse.raw, hourse.others, hourse.created_at, hourse.updated_at, hourse.deleted_at,
    CONCAT(city.name, section.name, hourse.address) :: VARCHAR AS location,
    city.name :: TEXT AS city,
    section.name :: TEXT AS section,
    shape.name :: TEXT AS shape,
    (SELECT COUNT(1) FROM candidates) AS total_count
FROM hourse
INNER JOIN candidates USING(id)
INNER JOIN section ON (section.id = hourse.section_id)
INNER JOIN shape ON(shape.id = hourse.shape_id)
INNER JOIN city ON (city.id = section.city_id)
ORDER BY hourse.section_id, hourse.age, hourse.main_area, hourse.price
`

type GetHoursesParams struct {
	City        interface{}
	Section     interface{}
	Shape       interface{}
	MaxPrice    interface{}
	MinPrice    interface{}
	Age         interface{}
	MaxMainArea interface{}
	MinMainArea interface{}
}

type GetHoursesRow struct {
	ID          int32
	UniversalID uuid.UUID
	SectionID   int32
	ShapeID     int32
	Link        string
	Layout      sql.NullString
	Address     sql.NullString
	Price       string
	Floor       string
	Age         string
	Area        string
	MainArea    sql.NullString
	Raw         json.RawMessage
	Others      []string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	Location    string
	City        string
	Section     string
	Shape       string
	TotalCount  int64
}

func (q *Queries) GetHourses(ctx context.Context, arg GetHoursesParams) ([]GetHoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, getHourses,
		arg.City,
		arg.Section,
		arg.Shape,
		arg.MaxPrice,
		arg.MinPrice,
		arg.Age,
		arg.MaxMainArea,
		arg.MinMainArea,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHoursesRow
	for rows.Next() {
		var i GetHoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.UniversalID,
			&i.SectionID,
			&i.ShapeID,
			&i.Link,
			&i.Layout,
			&i.Address,
			&i.Price,
			&i.Floor,
			&i.Age,
			&i.Area,
			&i.MainArea,
			&i.Raw,
			pq.Array(&i.Others),
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Location,
			&i.City,
			&i.Section,
			&i.Shape,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSection = `-- name: GetSection :one
SELECT id, city_id, name, created_at, deleted_at FROM section WHERE name = $1
`

func (q *Queries) GetSection(ctx context.Context, name string) (Section, error) {
	row := q.db.QueryRowContext(ctx, getSection, name)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.CityID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getShape = `-- name: GetShape :one
SELECT id, name, created_at, deleted_at FROM shape WHERE name = $1
`

func (q *Queries) GetShape(ctx context.Context, name string) (Shape, error) {
	row := q.db.QueryRowContext(ctx, getShape, name)
	var i Shape
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const insertCity = `-- name: InsertCity :one
INSERT INTO city (name) VALUES ($1) ON CONFLICT(name) DO NOTHING RETURNING id, name, created_at, deleted_at
`

func (q *Queries) InsertCity(ctx context.Context, name string) (City, error) {
	row := q.db.QueryRowContext(ctx, insertCity, name)
	var i City
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const insertSection = `-- name: InsertSection :one
INSERT INTO section (name, city_id) VALUES ($1, $2) ON CONFLICT(name, city_id) DO NOTHING RETURNING id, city_id, name, created_at, deleted_at
`

type InsertSectionParams struct {
	Name   string
	CityID int32
}

func (q *Queries) InsertSection(ctx context.Context, arg InsertSectionParams) (Section, error) {
	row := q.db.QueryRowContext(ctx, insertSection, arg.Name, arg.CityID)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.CityID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const insertShape = `-- name: InsertShape :one
INSERT INTO shape (name) VALUES ($1) ON CONFLICT(name) DO NOTHING RETURNING id, name, created_at, deleted_at
`

func (q *Queries) InsertShape(ctx context.Context, name string) (Shape, error) {
	row := q.db.QueryRowContext(ctx, insertShape, name)
	var i Shape
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listCities = `-- name: ListCities :many
SELECT name FROM city
`

func (q *Queries) ListCities(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listCities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSectionByCity = `-- name: ListSectionByCity :many
SELECT section.name FROM section INNER JOIN city ON (city.id = section.city_id) WHERE city.name = $1 ORDER BY section.name
`

func (q *Queries) ListSectionByCity(ctx context.Context, name string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listSectionByCity, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShape = `-- name: ListShape :many
SELECT name FROM shape WHERE name != '' ORDER BY name
`

func (q *Queries) ListShape(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listShape)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertHourse = `-- name: UpsertHourse :exec
INSERT INTO hourse (section_id, link, layout, address, price, floor, shape_id, age, area, main_area, raw, others ,created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 ,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (link) DO UPDATE SET price = $5, raw = $11, age = $8, updated_at = CURRENT_TIMESTAMP
`

type UpsertHourseParams struct {
	SectionID int32
	Link      string
	Layout    sql.NullString
	Address   sql.NullString
	Price     string
	Floor     string
	ShapeID   int32
	Age       string
	Area      string
	MainArea  sql.NullString
	Raw       json.RawMessage
	Others    []string
}

func (q *Queries) UpsertHourse(ctx context.Context, arg UpsertHourseParams) error {
	_, err := q.db.ExecContext(ctx, upsertHourse,
		arg.SectionID,
		arg.Link,
		arg.Layout,
		arg.Address,
		arg.Price,
		arg.Floor,
		arg.ShapeID,
		arg.Age,
		arg.Area,
		arg.MainArea,
		arg.Raw,
		pq.Array(arg.Others),
	)
	return err
}
